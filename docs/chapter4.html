<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 4: Parsing - Introduction to Compilers and Language Design</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="chapter1.html"><strong aria-hidden="true">1.</strong> Chapter 1: Introduction</a></li><li class="chapter-item expanded "><a href="chapter2.html"><strong aria-hidden="true">2.</strong> Chapter 2: A Quick Tour</a></li><li class="chapter-item expanded "><a href="chapter3.html"><strong aria-hidden="true">3.</strong> Chapter 3: Scanning</a></li><li class="chapter-item expanded "><a href="chapter4.html" class="active"><strong aria-hidden="true">4.</strong> Chapter 4: Parsing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Introduction to Compilers and Language Design</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="parsing"><a class="header" href="#parsing">Parsing</a></h1>
<h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<ul>
<li>To parse a computer program, we must first describe the form of
valid sentences in a language. This formal statement is known as a
context free grammar (CFG). Because they allow for recursion, CFGs
are more powerful than regular expressions and can express a richer
set of structures.</li>
<li>LL(1) grammars are CFGs that can be evaluated by considering only
the current rule and next token in the input stream. This property
makes it easy to write a hand-coded parser known as a recursive
descent parser.</li>
<li>LR(1) grammars are more general and more powerful than LL(1). Nearly
all useful programming languages can be written in LR(1) form.
However, the parsing algorithm for LR(1) grammars is more complex
and usually cannot be written by hand. Instead, it is common to use
a parser generator that will accept an LR(1) grammar and
automatically generate the parsing code.</li>
</ul>
<h1 id="context-free-grammars"><a class="header" href="#context-free-grammars">Context Free Grammars</a></h1>
<h2 id="terminal"><a class="header" href="#terminal">Terminal</a></h2>
<ul>
<li>A <strong>terminal</strong> is a discrete symbol that can appear in the language,
otherwise known as a <strong>token</strong> from the previous chapter.</li>
<li>Examples: keywords, operators and identifiers.</li>
<li>Convention: lower-case letters to represent terminals.</li>
</ul>
<h2 id="non-terminal"><a class="header" href="#non-terminal">Non terminal</a></h2>
<ul>
<li>A <strong>non-terminal</strong> represents a structure that can occur in a
language, but is not a literal symbol.</li>
<li>Examples: declarations, statements and expressions.</li>
<li>Convention: Upper-case letters to represent non terminals: <code>P</code> for
programs, <code>S</code> for statement, <code>E</code> for expression etc.</li>
</ul>
<h2 id="sentence"><a class="header" href="#sentence">Sentence</a></h2>
<ul>
<li>A <strong>sentence</strong> is a valid sequence of terminals in a language.</li>
</ul>
<h2 id="sentential-form"><a class="header" href="#sentential-form">Sentential form</a></h2>
<ul>
<li>A <strong>sentential form</strong> is a valid sequence of terminals and non
terminals.</li>
<li>Convention: Greek symbols to represent sentential forms. Example:
<em>α</em>, <em>β</em> and <em>γ</em> to represent possibly mixed sequence of terminals
and non-terminals. We will use a seqence like
<em>Y</em><sub>1</sub><em>Y</em><sub>2</sub>...<em>Y</em><sub><em>n</em></sub> to indicate the
individual symbols in a sentential form: <em>Y</em><sub><em>i</em></sub> may
either be a terminal or non terminal.</li>
</ul>
<h2 id="context-free-grammar-cfg"><a class="header" href="#context-free-grammar-cfg">Context Free Grammar (CFG)</a></h2>
<ul>
<li>A <strong>CFG</strong> is a list of <strong>rules</strong> that formally describe the
allowable sentences in a language.</li>
<li>The left hand side of each rule is always a single non-terminal.</li>
<li>The right hand side of a rule is a <strong>sentential form</strong> that
describes an allowable form of that non-terminal.</li>
<li>Example rule: <code>A -&gt; xXy</code> indicates that the non-terminal <code>A</code>
represents a terminal <code>x</code> followed by a non-terminal <code>X</code> and a
terminal <code>y</code>.</li>
<li>The right hand side of a rule can be <em>ϵ</em> to indicate that the rule
produces nothing.</li>
<li>The first rule is special: it is the top level definition of
aprogram and it's non terminal is known as the <strong>start symbol</strong></li>
</ul>
<p>Sample CFG describing expressions involving addition, integers and
identifiers:</p>
<p><a href="./images/c4_g2.png"><img src="./images/c4_g2.png" alt="" /></a></p>
<p>For brevity, the above grammar can also be written as:</p>
<p>E -&gt; E + E | ident | int</p>
<h2 id="deriving-sentences"><a class="header" href="#deriving-sentences">Deriving Sentences</a></h2>
<ul>
<li>Each grammar describes a (possibly infinite) set of sentences, which
is known as the <strong>language</strong> of the grammar.</li>
<li>To prove that a given sentence is a member of that language, we must
show that there exists a sequence of rule applications that connects
the start symbol with the desired sentence.</li>
<li>A sequence of rule applications is known as a <strong>derivation</strong> and a
double arrow (⇒) is used to show that one sentential form is equal
to another by applying a given rule. Example: E ⇒ int by applying
rule 4 of grammer G2.</li>
</ul>
<p>There are two approaches to derivation:</p>
<ul>
<li>top-down: Begin with the start symbol, and then apply rules in the
CFG to expand non terminals until reaching the desired sentence.</li>
<li>bottom-up: Begin with the desired setence, and then apply the rules
backwards until reaching the start symbol.</li>
</ul>
<p>For example, <code>ident + int + int</code> is a sentence in this language and here
is one top-down derivation to prove it:</p>
<p><a href="./images/c4_g2_top_down.png"><img src="./images/c4_g2_top_down.png" alt="" /></a></p>
<p>And similar proof using bottom-up derivation:</p>
<p><img src="./images/c4_g2_bottom_up.png" alt="" /></p>
<p>It is quite possible for two different grammars to generate the same
language, in which case we describe them as having <strong>weak equivalence</strong>.</p>
<h2 id="ambiguous-grammars"><a class="header" href="#ambiguous-grammars">Ambiguous Grammars</a></h2>
<ul>
<li>An <strong>ambiguous grammar</strong> allows for more than one possible
derivation of the same sentence.</li>
<li>Example: The sentence <code>ident + int + int</code> can have two derivations:</li>
</ul>
<p><img src="./images/c4_ambigous_grammar.png" alt="" /></p>
<ul>
<li>Does it matter in the above case ? It certainly does!</li>
<li>In a language like Java such a sentence <code>hello + 5 + 5</code> could be
interpreted as either <code>hello55</code> or <code>hello10</code> and that's not good.</li>
<li>It is possible to re-write a grammer so that it is not ambiguous. In
the common case of binary operators, we can require that one side of
the expression be an atomic term (T), like this:</li>
</ul>
<p><a href="./images/c4_g3.png"><img src="./images/c4_g3.png" alt="" /></a></p>
<ul>
<li>With this change, the grammer is no longer ambigous. But it still
accepts the same language as Grammer <em>G</em><sub>2</sub></li>
<li>If you want to construct a grammar with more operators (division,
muliplication) - then the usual approach is to construct a grammar
with multiple levels that reflect the intended precedence of
operators:</li>
</ul>
<p><a href="./images/c4_g4.png"><img src="./images/c4_g4.png" alt="" /></a></p>
<p>Grammar which supports two if statements (if-then and if-then-else
variant):</p>
<p><a href="./images/c4_g5.png"><img src="./images/c4_g5.png" alt="" /></a></p>
<p>The above grammer is ambiguous because it allows for two derivations of
this sentence:</p>
<ul>
<li>If E then if E then other else other</li>
</ul>
<p>There are two derivations of this sentence:</p>
<ul>
<li>If E then (if E then other else other)</li>
<li>If E then (if E then other) else other</li>
</ul>
<h1 id="ll-grammars"><a class="header" href="#ll-grammars">LL Grammars</a></h1>
<ul>
<li>LL(1) grammars are a subset of CFGs that are easy to parse with
simple algorithms.</li>
<li>A grammar is LL(1) if it can be parsed by considering only one
non-terminal and the next token in the input stream.</li>
</ul>
<p>To ensure a grammar is LL(1) we must do the following:</p>
<ul>
<li>Remove any ambiguity as shown above.</li>
<li>Eliminate any left recursion.</li>
<li>Eliminate any common left prefixes.</li>
</ul>
<h2 id="eliminating-left-recursion"><a class="header" href="#eliminating-left-recursion">Eliminating Left recursion</a></h2>
<p>LL(1) grammars cannot contain <strong>left recursion</strong> which is a rule of the
form A → A<em>α</em> or, more generally, any rule A → B<em>β</em> such that B ⇒ A<em>γ</em>
by some sequence of derivations.</p>
<p><a href="./images/c4_elim_left_recur.png"><img src="./images/c4_elim_left_recur.png" alt="" /></a></p>
<h2 id="eliminating-common-left-prefixes"><a class="header" href="#eliminating-common-left-prefixes">Eliminating Common Left Prefixes</a></h2>
<p><a href="./images/c4_elim_comm_prefix_1.png"><img src="./images/c4_elim_comm_prefix_1.png" alt="" /></a></p>
<p>Fixing the grammar will result in:</p>
<p><a href="./images/c4_g8.png"><img src="./images/c4_g8.png" alt="" /></a></p>
<h2 id="first-and-follow-sets"><a class="header" href="#first-and-follow-sets">First and Follow Sets</a></h2>
<ul>
<li>In order to construct a complete parser for an LL(1) grammar, we
must compute two sets, known as <code>FIRST</code> and <code>FOLLOW</code>.</li>
<li>Informally, FIRST(<em>α</em>) indicates the set of terminals (including
<em>ϵ</em>) that could potentially appear at the beginning of any
<strong>derivation</strong> of <em>α</em>.</li>
<li>FOLLOW(A) indicates the set of terminals (including $) that could
potentially occur after any derivation of non-terminal A.</li>
<li>Given the contents of these two set, the LL(1) parser will always
know <code>which rule to pick next</code>.</li>
</ul>
<p><a href="./images/c4_first_set.png"><img src="./images/c4_first_set.png" alt="" /></a></p>
<p>For non terminals, it says this:</p>
<p>For each rule X → <em>Y</em><sub>1</sub><em>Y</em><sub>2</sub>...<em>Y</em><sub><em>k</em></sub> in
a grammar G:</p>
<ul>
<li>FIRST(X) = a if FIRST(Y<sub>1</sub>) = a or (a =
FIRST(Y<sub>n</sub>) and Y<sub>1</sub>…Y<sub>n</sub>  ⇒ <em>ϵ</em> )</li>
</ul>
<p>In the above <em>a</em> = FIRST(<em>Y</em><sub><em>n</em></sub>) refers to <em>n</em> where n can be
1,2 or <em>n</em></p>
<p><em>Y</em><sub>1</sub>...<em>Y</em><sub><em>n</em> − 1</sub> ⇒ <em>ϵ</em> means
<em>ϵ</em> ∈ FIRST(<em>Y</em><sub>1</sub>)...<em>ϵ</em> ∈ FIRST(<em>Y</em><sub><em>n</em> − 1</sub>)</p>
<p><a href="./images/c4_follow_sets.png"><img src="./images/c4_follow_sets.png" alt="" /></a></p>
<p>I also found the following source very helpful:</p>
<ul>
<li><a href="https://www.jambe.co.nz/UNI/FirstAndFollowSets.html">jambe.con.nz
source</a> (For
first sets)</li>
<li><a href="http://www.cs.ecu.edu/karl/5220/spr16/Notes/Top-down/follow.html">cs.ecu.edu
source</a>
<a href="https://web.archive.org/web/20190203020902/http://www.cs.ecu.edu/karl/5220/spr16/Notes/Top-down/follow.html">Archive
link</a>
(For follow set, example specifically)</li>
</ul>
<p>I personally found that working out the examples, let me to understand
the above algorithm better. Always going back to the informal definition
above will help you. Now let's see an example:</p>
<p><a href="./images/c4_g9.png"><img src="./images/c4_g9.png" alt="" /></a></p>
<p>You can also use this <a href="https://hackage.haskell.org/package/context-free-grammar-0.1.1/docs/Data-Cfg-Analysis.html">Haskell
module</a>
to find them. (Future todo: Write a blog post about it)</p>
<p>Now for Grammer <em>G</em><sub>9</sub>, let's find out the follow sets:</p>
<p>FOLLOW(P) = {$} since P is the start state.</p>
<p>FOLLOW(E)</p>
<p>FOLLOW(E) contains $ since the sentinel form E shows that. (P =&gt; E)</p>
<p>E =&gt; TE' =&gt; FT'E' =&gt; (E)T'E'</p>
<p>yields a sentinel form where E is followed by <code>)</code></p>
<p>FOLLOW(E')</p>
<p>P =&gt; E =&gt; TE' =&gt; E'</p>
<p>So, FOLLOW(E') contains $.</p>
<p>T =&gt; FT' =&gt; (E)T' =&gt; (TE')T'</p>
<p>yields a sentinel form where E' is followed by <code>)</code></p>
<p>FOLLOW(T)</p>
<p>P =&gt; E =&gt; TE' =&gt; T</p>
<p>So, FOLLOW(T) contains $.</p>
<p>TE' =&gt; T+TE'</p>
<p>yields a sentinel form where T is followed by <code>+</code></p>
<p>T =&gt; FT' =&gt; (E)T' =&gt; (TE')T' =&gt; (T)T'</p>
<p>yields a sentinel form where T is followed by <code>)</code></p>
<p>FOLLOW(T')</p>
<p>P =&gt; E =&gt; TE' =&gt; FT'E' =&gt; FT' =&gt; T</p>
<p>We know that FOLLOW(T) contains $</p>
<p>T' =&gt; *FT' =&gt; *(E)T' =&gt; *(+TE')T' =&gt; *(+FT')T'</p>
<p>yields a sentinel form where T' is followed by <code>)</code></p>
<p>FT' =&gt; (E)T' =&gt; (TE')T' =&gt; (FT'E')T' =&gt; (FT'+TE)T'</p>
<p>yields a sentinel form wherer T' is followed by <code>+</code></p>
<p>FOLLOW(F)</p>
<p>P =&gt; E =&gt; TE' =&gt; T =&gt; FT' =&gt; F</p>
<p>So, Follow(F) contains $</p>
<p>FT' =&gt; F*FT'</p>
<p>yields a sentinel form where F is followd by <code>*</code></p>
<p>TE' =&gt; T+TE' =&gt; FT'+TE' =&gt; F+TE'</p>
<p>yields a sentinel form where F is followed by <code>+</code></p>
<p>FT' =&gt; F*FT' =&gt; F*(E)T' =&gt; F*(TE')T' =&gt; F*(T)T' =&gt; F*(FT')T'
=&gt; F*(F)T'</p>
<p>yiels a sentinel form where F is followed by <code>)</code></p>
<h2 id="recursive-descent-parsing"><a class="header" href="#recursive-descent-parsing">Recursive Descent Parsing</a></h2>
<ul>
<li>LL(1) grammars are very amenable to write simple hand-coded parsers.</li>
<li>A common approach is a <strong>recursive descent parser</strong> in which there
is one simple function for each non-terminal in the grammar. The
body of the function follow the right hand sides of the
corresponding rules: non-terminal results in a call to another parse
function, while terminals result in considering the next token.</li>
</ul>
<h2 id="table-driven-parsing"><a class="header" href="#table-driven-parsing">Table Driven Parsing</a></h2>
<ul>
<li>An LL(1) grammar can also be parsed using generalized table driven
code.</li>
<li>A table driven parser requires a grammar, a parse table and a stack
to represent the current set of non-terminals.</li>
<li>The <strong>LL(1) parse table</strong> is used to determine which rule should be
applied for any combination of non-terminal on the stack and next
token on the input stream.</li>
</ul>
<p><a href="./images/c4_l1_parse_table.png"><img src="./images/c4_l1_parse_table.png" alt="" /></a></p>
<p><a href="./images/c4_parse_table_g9.png"><img src="./images/c4_parse_table_g9.png" alt="" /></a></p>
<p><a href="./images/c4_ll_parsing_algo.png"><img src="./images/c4_ll_parsing_algo.png" alt="" /></a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
